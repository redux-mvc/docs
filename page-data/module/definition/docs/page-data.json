{"componentChunkName":"component---src-pages-module-definition-docs-mdx","path":"/module/definition/docs/","result":{"pageContext":{"frontmatter":{"title":"Decorators","tabs":["Usage","Docs"],"description":"Decorators api docs"},"relativePagePath":"/module/definition/docs.mdx","titleType":"page","MdxNode":{"id":"640a4e53-5f9f-502a-864f-c3bb1ee925d5","children":[],"parent":"5298720f-a619-5fec-bec5-fea9a71e0ec0","internal":{"content":"---\ntitle: Decorators\ntabs: ['Usage', 'Docs']\ndescription: Decorators api docs\n---\n\n<AnchorLinks>\n  <AnchorLink>addReducer</AnchorLink>\n  <AnchorLink>addLifecycle</AnchorLink>\n  <AnchorLink>addBridge</AnchorLink>\n  <AnchorLink>createModule</AnchorLink>\n</AnchorLinks>\n\n## addReducer\n\n- Creates a reducer from all the module dependencies.\n- Merges the iniState from all the module dependencies.\n- Merges the reducer functions from all the module dependencies.\n\n### Usage\n\n  - Should be executed after merging all the modules:\n\n    ```ts\n    const newModule = R.compose(\n        ...\n        addReducer(),\n        ...\n        merge(counter),\n        merge(searchBar)\n    )(module)\n\n    ```\n\n### Return value\n\n  - **newModule**\n\n  ```ts\n  newModule = {\n      ...module,\n      iniState: Object,\n      reduers: Map<ReducerFunction>,\n      reducer(state, action) {...},\n  }\n\n  ```\n\n**Methods:**\n\n  - **reducer**\n\n  ```ts\n  reducer: (previousState: Object, action: ActionPayload) -> nextState: Object\n\n  ```\n\n  Computes the *nextState* out of the *previousState* and *action*\n\n---\n\n## addLifecycle\n\nAdds lifecycle *constructor* and *componentWillUnmount* methods to the *module* for store creation. This methods will be called by the *redux-mvc Context* provider.\n\n### Usage\n\n  - Should be executed after all the other decorators.\n\n    ```ts\n    const newModule = R.compose(\n        addLifecycle(),\n        ...\n        merge(counter)\n    )(module)\n\n    ```\n\n### Return value\n  - **newModule**\n\n  ```ts\n  newModule = {\n      ...module,\n      constructor() {...},\n      componentWillUnmount() {...}\n  }\n\n  ```\n\n**Methods:**\n\n  - **constructor:**\n\n  ```ts\n  constructor: ({ moduleInstances, contextId, persist }) -> moduleInstance: ModuleInstance\n\n  ```\n\n  Creates the *store* and returns the *moduleInstance*.\n\n  Parameters:\n\n    1. `moduleInstances: Map<ModuleInstance>`\n\n      All the instances of modules keep by the *Context* provider.\n\n    2. `contextId: Symbol | String`\n\n      The id of the context.\n\n    3. `persist: Boolean`\n\n      Indicates to persist the store object after the *Context* is unmounted.\n\n  Return Value\n\n    - Should return the *moduleInstance* object with the *store* in it.\n\n    ```ts\n    moduleInstance = {\n      store: StoreObject\n    }\n\n    ```\n\n\n  - **componentWillUnmount**\n\n  ```ts\n  componentWillUnmount: ({ moduleInstances, contextId, persist }) -> moduleInstance: ModuleInstance\n\n  ```\n\n  Removes the *store* from the *moduleInstance* if *persist* is false.\n\n  Parameters\n\n    1. `moduleInstances: Map<ModuleInstance>`\n\n      All the instances of modules keep by the *Context* provider.\n\n    2. `contextId: Symbol | String`\n\n      The id of the context.\n\n    3. `persist: Boolean`\n\n      Indicates to persist the store object after the *Context* is unmounted.\n\n  Return Value\n\n    - It may return the *moduleInstance* object with the *store* in it.\n\n    ```ts\n    moduleInstance = {\n      store?: StoreObject\n    }\n\n    ```\n\n---\n\n## addBridge\n\nAdds the *trackGlobalNamespaces* array and the *dispatchToGlobal* filter function, that will later be used by the bridgeMiddleware.\n\n### Usage\n\n  - Should be executed after any *merge* decorator if you want to override the default *trackGlobalNamespaces* and *dispatchToGlobal*.\n\n  ```ts\n  const newModule = R.compose(\n      addBridge({ trackGlobalNamespaces, dispatchToGlobal })\n      ...\n      merge(searchBar),\n  )(module)\n\n  ```\n\n### Parameters\n\n  1. `trackGlobalNamespaces?: Array<String>`\n\n    The array of namespace dependencies from the *global context*.\n\n    If *trackGlobalNamespaces* is not passed, then *addBridge* will merge the *trackGlobalNamespaces* from all the module dependencies.\n\n  2. `dispatchToGlobal?: (action: ActionPayload) -> Boolean`\n\n    This predicate function will be used by the *bridgeMiddleware* to forward actions to the *global context*.\n\n    If *dispatchToGlobal* is not passed, then *addBridge* will dispatch to the *global context* any action that is not in any *namespace* of the module dependencies.\n\n### Return value\n\n  - **newModule**\n\n  ```ts\n  newModule = {\n      ...module,\n      trackGlobalNamespaces,\n      dispatchToGlobal,\n  }\n\n  ```\n  \n---\n\n## createModule\n\nHelper.\n\nApplies *addReducer* and *addLifecycle* in that order to create a module.\n\n\n### Usage\n\n  - Can be executed by itself,\n\n  ```ts\n  const newModule = creatModule(model)\n\n  ``` \n\n  or after any other decorator.\n\n  ```ts\n  const newModule = R.compose(\n    creatModule, \n    ...\n    addBridge(...),\n    merge(searchBar),\n    merge(counter)\n  )(model)\n\n  ``` \n\n### Parameters\n\n  1. `model: ModelInterface`\n\n### Return value\n\n  - **newModule**\n\n  ```ts\n  newModule = {\n      ...model,\n      reducer(state, action) {...},\n      constructor() {}, // creates the store object\n      componentWillUnmount() {} // creates the store object\n  }\n\n  ```\n","type":"Mdx","contentDigest":"1bd57cd2c3c9be1ef0586e11b2a3ee79","counter":97,"owner":"gatsby-plugin-mdx"},"frontmatter":{"title":"Decorators","tabs":["Usage","Docs"],"description":"Decorators api docs"},"exports":{},"rawBody":"---\ntitle: Decorators\ntabs: ['Usage', 'Docs']\ndescription: Decorators api docs\n---\n\n<AnchorLinks>\n  <AnchorLink>addReducer</AnchorLink>\n  <AnchorLink>addLifecycle</AnchorLink>\n  <AnchorLink>addBridge</AnchorLink>\n  <AnchorLink>createModule</AnchorLink>\n</AnchorLinks>\n\n## addReducer\n\n- Creates a reducer from all the module dependencies.\n- Merges the iniState from all the module dependencies.\n- Merges the reducer functions from all the module dependencies.\n\n### Usage\n\n  - Should be executed after merging all the modules:\n\n    ```ts\n    const newModule = R.compose(\n        ...\n        addReducer(),\n        ...\n        merge(counter),\n        merge(searchBar)\n    )(module)\n\n    ```\n\n### Return value\n\n  - **newModule**\n\n  ```ts\n  newModule = {\n      ...module,\n      iniState: Object,\n      reduers: Map<ReducerFunction>,\n      reducer(state, action) {...},\n  }\n\n  ```\n\n**Methods:**\n\n  - **reducer**\n\n  ```ts\n  reducer: (previousState: Object, action: ActionPayload) -> nextState: Object\n\n  ```\n\n  Computes the *nextState* out of the *previousState* and *action*\n\n---\n\n## addLifecycle\n\nAdds lifecycle *constructor* and *componentWillUnmount* methods to the *module* for store creation. This methods will be called by the *redux-mvc Context* provider.\n\n### Usage\n\n  - Should be executed after all the other decorators.\n\n    ```ts\n    const newModule = R.compose(\n        addLifecycle(),\n        ...\n        merge(counter)\n    )(module)\n\n    ```\n\n### Return value\n  - **newModule**\n\n  ```ts\n  newModule = {\n      ...module,\n      constructor() {...},\n      componentWillUnmount() {...}\n  }\n\n  ```\n\n**Methods:**\n\n  - **constructor:**\n\n  ```ts\n  constructor: ({ moduleInstances, contextId, persist }) -> moduleInstance: ModuleInstance\n\n  ```\n\n  Creates the *store* and returns the *moduleInstance*.\n\n  Parameters:\n\n    1. `moduleInstances: Map<ModuleInstance>`\n\n      All the instances of modules keep by the *Context* provider.\n\n    2. `contextId: Symbol | String`\n\n      The id of the context.\n\n    3. `persist: Boolean`\n\n      Indicates to persist the store object after the *Context* is unmounted.\n\n  Return Value\n\n    - Should return the *moduleInstance* object with the *store* in it.\n\n    ```ts\n    moduleInstance = {\n      store: StoreObject\n    }\n\n    ```\n\n\n  - **componentWillUnmount**\n\n  ```ts\n  componentWillUnmount: ({ moduleInstances, contextId, persist }) -> moduleInstance: ModuleInstance\n\n  ```\n\n  Removes the *store* from the *moduleInstance* if *persist* is false.\n\n  Parameters\n\n    1. `moduleInstances: Map<ModuleInstance>`\n\n      All the instances of modules keep by the *Context* provider.\n\n    2. `contextId: Symbol | String`\n\n      The id of the context.\n\n    3. `persist: Boolean`\n\n      Indicates to persist the store object after the *Context* is unmounted.\n\n  Return Value\n\n    - It may return the *moduleInstance* object with the *store* in it.\n\n    ```ts\n    moduleInstance = {\n      store?: StoreObject\n    }\n\n    ```\n\n---\n\n## addBridge\n\nAdds the *trackGlobalNamespaces* array and the *dispatchToGlobal* filter function, that will later be used by the bridgeMiddleware.\n\n### Usage\n\n  - Should be executed after any *merge* decorator if you want to override the default *trackGlobalNamespaces* and *dispatchToGlobal*.\n\n  ```ts\n  const newModule = R.compose(\n      addBridge({ trackGlobalNamespaces, dispatchToGlobal })\n      ...\n      merge(searchBar),\n  )(module)\n\n  ```\n\n### Parameters\n\n  1. `trackGlobalNamespaces?: Array<String>`\n\n    The array of namespace dependencies from the *global context*.\n\n    If *trackGlobalNamespaces* is not passed, then *addBridge* will merge the *trackGlobalNamespaces* from all the module dependencies.\n\n  2. `dispatchToGlobal?: (action: ActionPayload) -> Boolean`\n\n    This predicate function will be used by the *bridgeMiddleware* to forward actions to the *global context*.\n\n    If *dispatchToGlobal* is not passed, then *addBridge* will dispatch to the *global context* any action that is not in any *namespace* of the module dependencies.\n\n### Return value\n\n  - **newModule**\n\n  ```ts\n  newModule = {\n      ...module,\n      trackGlobalNamespaces,\n      dispatchToGlobal,\n  }\n\n  ```\n  \n---\n\n## createModule\n\nHelper.\n\nApplies *addReducer* and *addLifecycle* in that order to create a module.\n\n\n### Usage\n\n  - Can be executed by itself,\n\n  ```ts\n  const newModule = creatModule(model)\n\n  ``` \n\n  or after any other decorator.\n\n  ```ts\n  const newModule = R.compose(\n    creatModule, \n    ...\n    addBridge(...),\n    merge(searchBar),\n    merge(counter)\n  )(model)\n\n  ``` \n\n### Parameters\n\n  1. `model: ModelInterface`\n\n### Return value\n\n  - **newModule**\n\n  ```ts\n  newModule = {\n      ...model,\n      reducer(state, action) {...},\n      constructor() {}, // creates the store object\n      componentWillUnmount() {} // creates the store object\n  }\n\n  ```\n","fileAbsolutePath":"/Users/gonzaloacosta/workspace/redux-mvc-docs/src/pages/module/definition/docs.mdx"}}}}