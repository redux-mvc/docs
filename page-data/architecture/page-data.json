{"componentChunkName":"component---src-pages-architecture-mdx","path":"/architecture/","result":{"pageContext":{"frontmatter":{"title":"Architecture","description":"Module architecture of redux-mvc"},"relativePagePath":"/architecture.mdx","titleType":"page","MdxNode":{"id":"85eb506d-8bd2-5345-970b-cece7f923313","children":[],"parent":"0ecf97e0-1b60-5b49-a7a5-1ab3a523e241","internal":{"content":"---\ntitle: Architecture\ndescription: Module architecture of redux-mvc\n---\n\nimport Module from \"../images/Module.svg\";\nimport ModuleComposition from \"../images/ModuleComposition.svg\";\n\n<PageDescription>\n\nIntro to the *redux-mvc* architecture.\n\n</PageDescription>\n\n\n<AnchorLinks>\n  <AnchorLink>Module Diagram</AnchorLink>\n  <AnchorLink>Module Composition</AnchorLink>\n  <AnchorLink>Architecture Components</AnchorLink>\n  <AnchorLink>Implementation</AnchorLink>\n</AnchorLinks>\n\n## Module Diagram\n\nThe *module* is the unit of composition and architecture. This means that you can create bigger modules out of tiny ones and the architecture stays the same.\n\n<Column colLg='4'>\n  <Module />\n</Column>\n\n### Interactions\n\n- The *model* receives events (actions) from the *view* or the *controller* and updates the state.\n\n- The *view* consumes the *selectors* and dispatches events.\n\n- The *selectors* consume the *model* and the *global database*.\n\n- The *controller* observes the events from the *view* or the other *controllers* and dispatches new events or does I/O. They consume the *selectors*.\n\n## Module Composition\n\nGiven three modules (a, b, c) you can create a module out of them by using the *merge* decorator. You can use *views* from child modules in it, you can consume its *selectors* and watch its events with your *controller*.\n\nIn this case is clear why a *controller* can act as supervisor of other *modules*.\n\n<Column colLg='4'>\n  <ModuleComposition />\n</Column>\n\n## Architecture Components\n\n### Model\n\nThe *model* is the business logic layer where the state updates happen. \n\nYou can define the *iniState* and *reducers* in it. *redux-mvc* will dynamically generate the *actions* and *getters* for you so you avoid writing a bit of boilerplate.\n\n**Tools:** [*createModel*](/model/docs) decorator.\n\n### View\n\nThe *view* is the presentational layer. By using dependency injection we can keep it as stateless as possible.\n\n**Tools:** [*connect*](/context/connect/docs) hoc, [*useModel*](/context/useModel/docs) hook.\n\n### Controller\n\nThe *controller* in the *redux-mvc* architecture is the layer that coordinates the other layers by *modeling time*, meaning it will look at a stream of events (redux actions) and it will act accordingly by firing other events, calling the api or forking processes. The *controller* can also act as supervisor of child modules.\n\n*redux-mvc* does not bake in a *controller* layer, it's up to your needs an choice. Common redux controller layers are: *redux-saga*, *redux-thunk*, *redux-observable** ...\n\n**E.g.:** [sagas recipe](https://github.com/redux-mvc/core/blob/master/src/Examples/App/utils.js)\n\n### Selectors\n\n*selectors* is a layer of indirection that decouples the *view* from the *model*. It's also the place where you derive and/or combine data between several *models*.\n\n**Tools:** *createSelector*.\n  \n### Module\n\nThe *module* is the configuration layer that wires the *model* and *controller* and plugs other modules in. It adds the lifecycle methods that are required by the *context*.\n\n**Tools:** [*createModule*](/module/definition/docs).\n\n### Context\n\nThe *context* is where you run the page's *module*. \n\n**Tools:** [*createContext*](/context/creation/docs).\n\n### Global Database\n\nThe *global database* can be any store of global available data: *graphql*, *datascript* or even a *redux-mvc* data module. \n\nIn here you put any data that can be globally available, usually api data.\n\n**Tools:** [*createContext*](/middleware/bridge/usage) to set the global context, [*addBridge*](/module/definition/docs#addbridge) decorator to consume the global context.\n\n**Note:** as of this time the only global store I use is other *redux-mvc* module. In the future I would like to try using *graphql* or *datascript* as database.\n\n## Implementation\n\nThe architecture diagram above can be implemented with any tool that supports composition of models and a global context to run the model. \n\n*redux* is functional, data for the state and functions for updates, is easily composable. \n\n*react* context api works just fine as model provider.\n\nOther important thing to notice about the implementation is the *decorators* api for the modules. It is useful for creating new modules out of other modules, by composition or enhancement of functionalities, but more important, it allows *redux-mvc* to be customized by the consumer. You can rewrite any of the decorators meanwhile it does what is supposed to do and implements the decorator api. In fact this is the recipe to add your *controller* layer of preference.\n","type":"Mdx","contentDigest":"68870feb0b6fa1fb98f0ca946f2b1670","counter":95,"owner":"gatsby-plugin-mdx"},"frontmatter":{"title":"Architecture","description":"Module architecture of redux-mvc"},"exports":{},"rawBody":"---\ntitle: Architecture\ndescription: Module architecture of redux-mvc\n---\n\nimport Module from \"../images/Module.svg\";\nimport ModuleComposition from \"../images/ModuleComposition.svg\";\n\n<PageDescription>\n\nIntro to the *redux-mvc* architecture.\n\n</PageDescription>\n\n\n<AnchorLinks>\n  <AnchorLink>Module Diagram</AnchorLink>\n  <AnchorLink>Module Composition</AnchorLink>\n  <AnchorLink>Architecture Components</AnchorLink>\n  <AnchorLink>Implementation</AnchorLink>\n</AnchorLinks>\n\n## Module Diagram\n\nThe *module* is the unit of composition and architecture. This means that you can create bigger modules out of tiny ones and the architecture stays the same.\n\n<Column colLg='4'>\n  <Module />\n</Column>\n\n### Interactions\n\n- The *model* receives events (actions) from the *view* or the *controller* and updates the state.\n\n- The *view* consumes the *selectors* and dispatches events.\n\n- The *selectors* consume the *model* and the *global database*.\n\n- The *controller* observes the events from the *view* or the other *controllers* and dispatches new events or does I/O. They consume the *selectors*.\n\n## Module Composition\n\nGiven three modules (a, b, c) you can create a module out of them by using the *merge* decorator. You can use *views* from child modules in it, you can consume its *selectors* and watch its events with your *controller*.\n\nIn this case is clear why a *controller* can act as supervisor of other *modules*.\n\n<Column colLg='4'>\n  <ModuleComposition />\n</Column>\n\n## Architecture Components\n\n### Model\n\nThe *model* is the business logic layer where the state updates happen. \n\nYou can define the *iniState* and *reducers* in it. *redux-mvc* will dynamically generate the *actions* and *getters* for you so you avoid writing a bit of boilerplate.\n\n**Tools:** [*createModel*](/model/docs) decorator.\n\n### View\n\nThe *view* is the presentational layer. By using dependency injection we can keep it as stateless as possible.\n\n**Tools:** [*connect*](/context/connect/docs) hoc, [*useModel*](/context/useModel/docs) hook.\n\n### Controller\n\nThe *controller* in the *redux-mvc* architecture is the layer that coordinates the other layers by *modeling time*, meaning it will look at a stream of events (redux actions) and it will act accordingly by firing other events, calling the api or forking processes. The *controller* can also act as supervisor of child modules.\n\n*redux-mvc* does not bake in a *controller* layer, it's up to your needs an choice. Common redux controller layers are: *redux-saga*, *redux-thunk*, *redux-observable** ...\n\n**E.g.:** [sagas recipe](https://github.com/redux-mvc/core/blob/master/src/Examples/App/utils.js)\n\n### Selectors\n\n*selectors* is a layer of indirection that decouples the *view* from the *model*. It's also the place where you derive and/or combine data between several *models*.\n\n**Tools:** *createSelector*.\n  \n### Module\n\nThe *module* is the configuration layer that wires the *model* and *controller* and plugs other modules in. It adds the lifecycle methods that are required by the *context*.\n\n**Tools:** [*createModule*](/module/definition/docs).\n\n### Context\n\nThe *context* is where you run the page's *module*. \n\n**Tools:** [*createContext*](/context/creation/docs).\n\n### Global Database\n\nThe *global database* can be any store of global available data: *graphql*, *datascript* or even a *redux-mvc* data module. \n\nIn here you put any data that can be globally available, usually api data.\n\n**Tools:** [*createContext*](/middleware/bridge/usage) to set the global context, [*addBridge*](/module/definition/docs#addbridge) decorator to consume the global context.\n\n**Note:** as of this time the only global store I use is other *redux-mvc* module. In the future I would like to try using *graphql* or *datascript* as database.\n\n## Implementation\n\nThe architecture diagram above can be implemented with any tool that supports composition of models and a global context to run the model. \n\n*redux* is functional, data for the state and functions for updates, is easily composable. \n\n*react* context api works just fine as model provider.\n\nOther important thing to notice about the implementation is the *decorators* api for the modules. It is useful for creating new modules out of other modules, by composition or enhancement of functionalities, but more important, it allows *redux-mvc* to be customized by the consumer. You can rewrite any of the decorators meanwhile it does what is supposed to do and implements the decorator api. In fact this is the recipe to add your *controller* layer of preference.\n","fileAbsolutePath":"/home/gonzalo/workspace/mac/redux-mvc-docs/src/pages/architecture.mdx"}}},"staticQueryHashes":["1054721580","1054721580","1364590287","2102389209","2102389209","2456312558","2746626797","2746626797","3037994772","3037994772","768070550"]}